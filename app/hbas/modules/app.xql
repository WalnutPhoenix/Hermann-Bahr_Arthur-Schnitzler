xquery version "3.1";

module namespace app="http://hbas.at/templates";
declare namespace tei="http://www.tei-c.org/ns/1.0";


import module namespace templates="http://exist-db.org/xquery/templates" ;
import module namespace config="http://hbas.at/config" at "config.xqm";

(:~
 : This is a sample templating function. It will be called by the templating module if
 : it encounters an HTML element with an attribute data-template="app:test" 
 : or class="app:test" (deprecated). The function has to take at least 2 default
 : parameters. Additional parameters will be mapped to matching request or session parameters.
 : 
 : @param $node the HTML node with the attribute which triggered this call
 : @param $model a map containing arbitrary data - used to pass information between template calls
 :)
declare function app:test($node as node(), $model as map(*)) {
    <p>Dummy template output generated by function app:test at {current-dateTime()}. The templating
        function was triggered by the data-template attribute <code>data-template="app:test"</code>.</p>
};

(: --------------------------- Test für die Startseite - später löschen  ----------------------------------------- :)
(: Filtert die Ausgegeben Files nach Dokumenttypen :)

declare
    %templates:wrap
function app:list-files($node as node(), $model as map(*), $type, $id) {
    let $data-path := 
    switch($type)
    case "T" return $config:data-root || "/texts"
    case "D" return $config:data-root || "/diaries"
    case "L" return $config:data-root || "/letters"
    default return $config:data-root
    let $data := collection($data-path)
    for $doc in $data//tei:TEI
return 
    $doc/@xml:id/string()
};


(: ---------------------- Typeswitch-Funktion zur Formatierung von Dokumenten ---------------------------- :)

declare function app:format($nodes as node()*) {
(: 
 : Typeswitch um Dokument zu formatieren: XML > HTML
 :)
    for $node in $nodes
    return
        typeswitch($node)
        
        
        (: tei:TEI nicht ausgeben :)
        
        case element(tei:TEI) return
                app:format($node/node())
        
        (: teiHeader-Daten > Meta :)
        (: tei:teiHeader zu html:div :)
            case element(tei:teiHeader) return
                <div class="teiHeader">{app:format($node/node())}</div>
        
        
        (: tei:body :)
        case element(tei:body) return
                <div class="col-md-6 text">{app:format($node/node())}</div>
        
        
        
        (: tei:div :)
        (: tei:persName zu html:span :)
            case element(tei:div) return
                <div class="type_{$node/@type}">{app:format($node/node())}</div>
        
        (: Personen, Orte, usw. :)
        
        (: tei:persName zu html:span :)
            case element(tei:persName) return
                <span class="persName" data-key="{$node/@key}">{app:format($node/node())}</span>
        
        (: tei:placeName zu html:span :)
            case element(tei:placeName) return
                <span class="placeName" data-key="{$node/@key}">{app:format($node/node())}</span>
                
        (: tei:orgName zu html:span :)
            case element(tei:orgName) return
                <span class="orgName" data-key="{$node/@key}">{app:format($node/node())}</span>
        
        (: tei:workName zu html:span :)
            case element(tei:workName) return
                <span class="workName" data-key="{$node/@key}">{app:format($node/node())}</span>
                
        (: tei:rs zu html:span :)
            case element(tei:rs) return
                <span class="rs rs_{$node/@type}" data-key="{$node/@key}">{app:format($node/node())}</span>
        
        
        (: Datum :)
        
        (: tei:date zu html:span :)
            case element(tei:date) return
                <span class="date" data-when="{$node/@when}">{app:format($node/node())}</span>
        
        (: Anchors :)
            (: tei:anchor zu html:a u.a. :)
            case element(tei:anchor) return
                (<a id="{$node/@xml:id}"/>,<span class="commentary">{app:format($node/node())}</span>)
                
                
        (: the following seven lines pass anything that isn't the element(exist:match) through without change :)
            case element() return
                element { node-name($node) } {
                    $node/@*,
                    for $child in $node/node()
                    return
                        app:format($child)
                }
            default return
                $node
};

(: ---------------------- correspDesc-Metadaten ---------------------------- :)

declare function app:corresp-meta($id) {
    let $corresp-data := collection($config:data-root)/id($id)//tei:correspDesc
    return
        <div class="correspMeta">
            <span class="sender">{$corresp-data/tei:sender}</span>
            <span class="addressee">{$corresp-data/tei:addressee}</span>
            <span class="placeSender">{$corresp-data/tei:placeSender}</span>
            <span class="placeAddressee">{$corresp-data/tei:placeAddressee}</span>
            <span class="dateSender">{$corresp-data/tei:dateSender}</span>
        </div>
    
};

(: --------------------------- view.html - Seite  ----------------------------------------- :)

declare
 %templates:wrap
 %templates:default("type", "")
 function app:page_view($node as node(), $model as map(*),$id,$type) {
 (: 
  : Seite zeigt ein einzelnes Dokument an. Welches angezeigt werden soll, wird per $id übergeben.
  : $id xml:id des Dokuments
  : $type für Listenansicht: T texts, D diaries, L letters 
 :)

let $output := if ($id!="") then
        app:view_single($id,$type)
    else
        app:view_list($type)
 return $output
 };

declare function app:view_list($type) {
    (:Gibt eine Liste mit allen verfügbaren Dokumenten aus:)
    (: soll sich später anhand von $type filtern lassen :)
    <div class="row">
    <h2>Verfügbare Dokumente</h2>
    {
       let $data-path :=
       if ($type) then
            switch($type)
                case "T" return $config:data-root || "/texts"
                case "D" return $config:data-root || "/diaries"
                case "L" return $config:data-root || "/letters"
            default return $config:data-root
        else $config:data-root
    let $data := collection($data-path)
    for $doc in $data//tei:TEI
    (:
    sortieren nach @when, @n:; bei Briefen sortieren nach senderDater > date ; bei Tagebuch body > date[1]
    bei Texten origDate
    :)
return
    <span class="docListItem">
        <span class="autor">{$doc//tei:titleStmt/tei:author/string()}</span>
        <span class="titel">{$doc//tei:titleStmt/tei:title[@level='a']/string()}</span>
        <a href="{concat('view.html?id=',$doc/@xml:id/string())}">{$doc/@xml:id/string()}</a>
    </span>
    }
    </div>
};

declare function app:view_single($id,$type) {
    (:Gibt eine Einzelansicht eines Dokuments aus:)
    <div class="row">
        <h2>{collection($config:data-root)/id($id)//tei:titleStmt/tei:title[@level='a']/text()}</h2>
        {
            if (substring($id,1,1)='L') then
                app:corresp-meta($id)
            else ()
        }
        
        {app:format(collection($config:data-root)/id($id))}
    </div>
    
    
};



(: register.html :)

declare
 %templates:wrap
 function app:register_view($node as node(), $model as map(*),$key, $type) {
 (: 
  Seite zeigt einen Registereintrag an: 
  entweder einen Einzeleintrag, wenn $key gesetzt ist,
  oder eine Liste, wenn $type gesetzt ist: 
  Werte für $type: p(persName), o(placeName), w(workName)
  
 :)

let $output := if ($key!="") then
        app:register_single($key,$type)
    else
        app:register_liste($type)
 return $output
 };



(: --------------------------- register-Liste  ----------------------------------------- :)

declare
function app:register_liste($type) {
    (: Werte für $type: p(persName), o(placeName), w(workName) :)
    let $liste :=
    for $key in
    switch ($type)
        case "p" return distinct-values(collection($config:data-root)//tei:persName/@key)
        case "o" return distinct-values(collection($config:data-root)//tei:placeName/@key)
        case "w" return distinct-values(collection($config:data-root)//tei:workName/@key)
        default return ()
        return
            <li><a href="{concat('register.html?key=',$key,'&amp;type=',$type)}">{$key}</a></li>
        return 
            <ul>{$liste}</ul>
};

declare function app:register_single($key,$type) {
        
        (:collection($config:data-root)//tei:persName)[@key=$key]/ancestor::tei:TEI:)
        let $liste :=
    for $doc in
    switch ($type)
        case "p" return collection($config:data-root)//tei:persName[@key=$key]/ancestor::tei:TEI
        case "o" return collection($config:data-root)//tei:placeName[@key=$key]/ancestor::tei:TEI
        case "w" return collection($config:data-root)//tei:workName[@key=$key]/ancestor::tei:TEI
        default return ()
        return
            <li><a href="{concat('view.html?id=',$doc/@xml:id)}">{$doc/@xml:id/string()}</a></li>
        return 
            <ul>{$liste}</ul>
};